Feature: Encrypt PII columns in purgo_playground.customer_360_raw_clone and save encryption key as JSON

  As a data engineer,
  I want to encrypt the PII columns (name, email, phone, zip) in the purgo_playground.customer_360_raw_clone table,
  so that PII data is protected and the encryption key is securely stored as a JSON file in the specified volume location.

  Background:
    Given the Unity Catalog is "purgo_databricks"
    And the schema is "purgo_playground"
    And the source table is "customer_360_raw"
    And the target clone table is "customer_360_raw_clone"
    And the PII columns to encrypt are "name", "email", "phone", "zip"
    And the encryption key file location is "/Volumes/agilisium_playground/purgo_playground/de_dq"
    And the encryption key file name format is "encryption_key_<current_datetime>.json" where <current_datetime> is in "yyyyMMdd_HHmmss" format
    And the encryption algorithm is "AES-256-GCM"
    And the encryption key is a randomly generated 256-bit (32-byte) base64-encoded string
    And the key JSON file must contain the key in the format: {"encryption_key": "<base64_key>"}
    And all non-PII columns must remain unaltered in the clone table

  Scenario: Drop and recreate the clone table before encryption
    Given the table "purgo_playground.customer_360_raw_clone" exists
    When the encryption process starts
    Then the table "purgo_playground.customer_360_raw_clone" should be dropped
    And a new table "purgo_playground.customer_360_raw_clone" should be created as a replica of "purgo_playground.customer_360_raw" with identical schema and data

  Scenario: Clone table does not exist before encryption
    Given the table "purgo_playground.customer_360_raw_clone" does not exist
    When the encryption process starts
    Then a new table "purgo_playground.customer_360_raw_clone" should be created as a replica of "purgo_playground.customer_360_raw" with identical schema and data

  Scenario: Generate and save encryption key as JSON
    When the encryption process starts
    Then a new 256-bit (32-byte) random encryption key should be generated
    And the key should be base64-encoded
    And a JSON file named "encryption_key_<current_datetime>.json" should be created in "/Volumes/agilisium_playground/purgo_playground/de_dq"
    And the JSON file should contain the key in the format: {"encryption_key": "<base64_key>"}
    And the file should be accessible and readable after creation

  Scenario Outline: Encrypt PII columns in the clone table (happy path)
    Given the table "purgo_playground.customer_360_raw_clone" exists and contains at least one row
    And the "<column>" column contains the value "<original_value>"
    When the encryption process is executed
    Then the "<column>" column value should be replaced with an AES-256-GCM encrypted and base64-encoded string
    And the encrypted value should not match the original value "<original_value>"
    And the encrypted value should be a non-null, non-empty string
    And all other columns in the row should remain unchanged

    Examples:
      | column | original_value         |
      | name   | John Doe              |
      | email  | john.doe@email.com    |
      | phone  | +1-555-123-4567       |
      | zip    | 90210                 |

  Scenario: Non-PII columns remain unaltered after encryption
    Given the table "purgo_playground.customer_360_raw_clone" contains a row with
      | id | name     | email               | phone         | company      | zip   |
      | 1  | Jane Doe | jane.doe@email.com  | 555-987-6543  | Acme Corp    | 10001 |
    When the encryption process is executed
    Then the "company" column value should remain "Acme Corp"
    And the "id" column value should remain 1

  Scenario: Null values in PII columns are handled correctly
    Given the table "purgo_playground.customer_360_raw_clone" contains a row with
      | id | name | email | phone | zip   |
      | 2  | null | null  | null  | null  |
    When the encryption process is executed
    Then the "name" column value should remain null
    And the "email" column value should remain null
    And the "phone" column value should remain null
    And the "zip" column value should remain null

  Scenario Outline: Validation - Encrypted values are not in plaintext and are base64-encoded
    Given the table "purgo_playground.customer_360_raw_clone" contains a row with "<column>" = "<original_value>"
    When the encryption process is executed
    Then the "<column>" value should not contain "<original_value>"
    And the "<column>" value should match the regex "^[A-Za-z0-9+/=]+$" (base64 format)

    Examples:
      | column | original_value         |
      | name   | Alice Smith           |
      | email  | alice.smith@email.com |
      | phone  | 123-456-7890          |
      | zip    | 12345                 |

  Scenario: Error - Source table does not exist
    Given the table "purgo_playground.customer_360_raw" does not exist
    When the encryption process starts
    Then the process should fail with error message "Source table purgo_playground.customer_360_raw does not exist."

  Scenario: Error - Unable to write encryption key file
    Given the encryption key file location "/Volumes/agilisium_playground/purgo_playground/de_dq" is not writable
    When the encryption process attempts to save the key file
    Then the process should fail with error message "Unable to write encryption key file to /Volumes/agilisium_playground/purgo_playground/de_dq."

  Scenario: Error - Encryption key generation fails
    Given the random key generation process fails
    When the encryption process starts
    Then the process should fail with error message "Encryption key generation failed."

  Scenario: Error - Encryption of PII column fails
    Given the encryption library throws an exception during encryption of the "email" column
    When the encryption process is executed
    Then the process should fail with error message "Encryption failed for column: email."

  Scenario: Idempotency - Re-running the process overwrites previous clone and key
    Given the table "purgo_playground.customer_360_raw_clone" exists with previously encrypted data
    And a previous encryption key file exists in "/Volumes/agilisium_playground/purgo_playground/de_dq"
    When the encryption process is re-executed
    Then the table "purgo_playground.customer_360_raw_clone" should be dropped and recreated as a fresh clone
    And all PII columns should be re-encrypted with a new key
    And a new encryption key file should be generated with the current datetime in the filename

  Scenario: Key file naming convention validation
    When the encryption process is executed at "2024-07-30 14:23:45"
    Then the encryption key file should be named "encryption_key_20240730_142345.json"
    And the file should exist in "/Volumes/agilisium_playground/purgo_playground/de_dq"

  Scenario: Key file content validation
    When the encryption process is executed
    Then the encryption key file should contain a single JSON object with the key "encryption_key"
    And the value should be a 44-character base64-encoded string (for 32 bytes)
    And the file should not contain any other fields

  Scenario: Data type and format validation for encrypted columns
    Given the table "purgo_playground.customer_360_raw_clone" contains a row with
      | id | name     | email               | phone         | zip   |
      | 3  | Bob Lee  | bob.lee@email.com   | 555-111-2222  | 60606 |
    When the encryption process is executed
    Then the "name" column value should be a string of length >= 24
    And the "email" column value should be a string of length >= 24
    And the "phone" column value should be a string of length >= 24
    And the "zip" column value should be a string of length >= 24

  Scenario: All acceptance criteria are met
    Given the encryption process completes successfully
    Then the table "purgo_playground.customer_360_raw_clone" should contain encrypted values for all PII columns
    And the encryption key file should exist in the specified location with correct naming and content
    And all non-PII columns should remain unchanged
    And null values in PII columns should remain null
    And the process should be repeatable and idempotent

